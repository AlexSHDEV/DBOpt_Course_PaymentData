### Выводы по заданию 1
- Перед запуском нашего бенчмарка база данных наполнена записями о 100 участниках в PaymentParticipant (и в зависимых таблицах соответственно).
- При отсутствии индексов 500 итераций записи платежа производится за время от 6123 до 14657 мс. Следовательно, дадим оценку времени как усредненное значение по 10 запускам - **10302 мс**.

---

Проанализировав еще раз программные компоненты БД PaymentData, удалось прийти к пониманию и сделать выводы о сути нагрузки:
- Триггер _T_PaymentParticipant_BU_ создает нагрузку, последовательно и многократно вызывая фунцкии подсчета баланса.
- Например, функция _F_CalculatePaymentParticipantBalance_ выполняет запросы типа SELECT - JOIN - ON, при этом регулярно обращаясь к зависымым таблицам.
- Хочу заметить, что индексы на ключи основных участников уже созданы (Project, Payee, Payer и другие).
- Функция подсчета для Project-баланса вызывает функции _F_CalculateBalanceByWork_ и _F_CalculateBalanceByMaterial_, и сами эти функции вызываются отдельно еще раз, при срабатывании триггера (кажется, это похоже на лишние вычисления, но я не уверен), хотя они вызываются рядом и последовательно.
- _F_CalculateBalanceByWork_ и _F_CalculateBalanceByMaterial_ делают запросы, например по полям _AccountType.Name_ и _ProfitByMaterial_ соотвественно, следовательно принято решения индексировать поля, затрагиваемые этими функциями.

---
В результате мне не удалось получить существенных результатов при данной конфигурации теста. Местами казалось, что оценка времени только ухудшилась.
